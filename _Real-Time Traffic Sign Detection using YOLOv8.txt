import os
from IPython.display import Video
Video("/kaggle/input/speed-and-traffic-sign-detection-test/output2.mp4", width=960, embed=True)
!pip install ultralytics
import os
import random
import pandas as pd
from PIL import Image
import cv2
from ultralytics import YOLO
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pathlib
import glob
from tqdm.notebook import trange, tqdm
import warnings
warnings.filterwarnings('ignore')
# Path to the images directory
image_dir = "/kaggle/input/cardetection/car/train/images"
image_files = os.listdir(image_dir)
label_files = os.listdir('/kaggle/input/cardetection/car/train/labels')
print(f"Total number of images: {len(image_files)}")
print(f"Total number of labels: {len(label_files)}")
image_files = sorted(os.listdir(image_dir))
random_image_file = random.choice(image_files)
img_path = os.path.join(image_dir, random_image_file)
image = Image.open(img_path)

# Get size and channels
width, height = image.size
mode = image.mode # 'RGB' for color, 'L' for grayscale, etc.

print(f"Size: {width} x {height}")
print(f"Mode: {mode}")
# Get a list of image files
image_files = sorted(os.listdir(image_dir))
random.shuffle(image_files) # Shuffle the list for randomness

# Select the first 5 random images
image_files = image_files[:5]

# Plot images
plt.figure(figsize=(15, 10))
for i, img_file in enumerate(image_files):
# Full path to the image
img_path = os.path.join(image_dir, img_file)

# Load the image
image = Image.open(img_path)

# Plot the image
plt.subplot(1, 5, i + 1) # Create a subplot for each image
plt.imshow(image)
plt.axis('off') # Hide axis

plt.tight_layout()
plt.show()


# Load a pre-trained YOLO model
model = YOLO("yolov8n.pt")

# Train the model
results = model.train(
data="/kaggle/input/cardetection/car/data.yaml",
epochs=30,
batch=-1,
optimizer='auto'
)


def display_confusion_matrix(post_training_files_path, cm_image_file):
image_path = os.path.join(post_training_files_path, cm_image_file)

if os.path.exists(image_path):
img = cv2.imread(image_path)
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

plt.figure(figsize=(10, 10), dpi=120)
plt.imshow(img)
plt.axis('off')
plt.title('Confusion Matrix')
plt.show()
else:
print(f"File {cm_image_file} not found at {post_training_files_path}")

# Path to the directory containing the image
post_training_files_path = '/kaggle/working/runs/detect'

# Filename of the confusion matrix image
cm_image_file = '/kaggle/working/runs/detect/train/confusion_matrix_normalized.png'

# Display the confusion matrix
display_confusion_matrix(post_training_files_path, cm_image_file)


def display_images(post_training_files_path, image_files):

for image_file in image_files:
image_path = os.path.join(post_training_files_path, image_file)
img = cv2.imread(image_path)
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

plt.figure(figsize=(10, 10), dpi=120)
plt.imshow(img)
plt.axis('off')
plt.show()

image_files = [
'F1_curve.png',
'P_curve.png',
'R_curve.png',
'PR_curve.png',
'results.png'
]


post_training_files_path = '/kaggle/working/runs/detect/train'
display_images(post_training_files_path, image_files)


Result_Final_model = pd.read_csv('/kaggle/working/runs/detect/train/results.csv')
Result_Final_model.tail(15)


Valid_model = YOLO('/kaggle/working/runs/detect/train/weights/best.pt')

# Evaluating the model on the validset
metrics = Valid_model.val(split = 'val')

# final results
print("precision(B): ", metrics.results_dict["metrics/precision(B)"])
print("metrics/recall(B): ", metrics.results_dict["metrics/recall(B)"])
print("metrics/mAP50(B): ", metrics.results_dict["metrics/mAP50(B)"])
print("metrics/mAP50-95(B): ", metrics.results_dict["metrics/mAP50-95(B)"])


# Normalization function
def normalize_image(image):
return image / 255.0

# Image resizing function
def resize_image(image, size=(640, 640)):
return cv2.resize(image, size)

# Path to validation images
dataset_path = '/kaggle/input/speed-and-traffic-sign-detection-test'
valid_images_path = dataset_path # Directly point to the root directory

# List of all jpg and jpeg images in the directory
image_files = [file for file in os.listdir(valid_images_path) if file.endswith('.jpg') or file.endswith('.jpeg')]

# Check if there are images in the directory
if len(image_files) > 0:
# Select a random image
selected_image = random.choice(image_files)
image_path = os.path.join(valid_images_path, selected_image)

# Load image
image = cv2.imread(image_path)

# Check if the image is loaded correctly
if image is not None:
# Resize image
resized_image = resize_image(image, size=(640, 640))
# Normalize image
normalized_image = normalize_image(resized_image)

# Convert the normalized image to uint8 data type
normalized_image_uint8 = (normalized_image * 255).astype(np.uint8)

# Predict with the model
results = Valid_model.predict(source=normalized_image_uint8, imgsz=640, conf=0.5)

# Plot image with thicker bounding box
annotated_image = results[0].plot(line_width=3) # Increased line width for thicker bounding box
annotated_image_rgb = cv2.cvtColor(annotated_image, cv2.COLOR_BGR2RGB)

# Display the image
plt.figure(figsize=(10, 10))
plt.imshow(annotated_image_rgb)
plt.axis('off')
plt.show()
else:
print(f"Failed to load image {image_path}")
else:
print("No images found in the directory.")


!ffmpeg -y -loglevel panic -i "/kaggle/input/speed-and-traffic-sign-detection-test/test video.mp4" output.mp4
from IPython.display import Video

# Display the converted video
Video("output.mp4", width=960)


# Predict using the model with streaming to handle large videos
results = Valid_model.predict(source="/kaggle/input/speed-and-traffic-sign-detection-test/test video.mp4", stream=True, save=True)


# Display the video
Video("/kaggle/input/speed-and-traffic-sign-detection-test/output2.mp4", width=960, embed=True)